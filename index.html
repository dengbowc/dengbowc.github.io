<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="一个二次猿的小站" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/icon.jpg?v=5.1.0" />






<meta name="description" content="邓波的个人站">
<meta property="og:type" content="website">
<meta property="og:title" content="一个二次猿的小站">
<meta property="og:url" content="https://dengbowc.github.io/index.html">
<meta property="og:site_name" content="一个二次猿的小站">
<meta property="og:description" content="邓波的个人站">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="一个二次猿的小站">
<meta name="twitter:description" content="邓波的个人站">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://dengbowc.github.io/"/>





  <title> 一个二次猿的小站 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">一个二次猿的小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">会一点编程，会一点日语，会一点音乐~</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-objectivec">
          <a href="/categories/Objective-C" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Objective-c
          </a>
        </li>
      
        
        <li class="menu-item menu-item-daily">
          <a href="/categories/daily" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            随笔
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://dengbowc.github.io/2017/03/19/KVO底层实现探究/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="邓波">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bolgIcon.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="一个二次猿的小站">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="一个二次猿的小站" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/19/KVO底层实现探究/" itemprop="url">
                  KVO底层实现探究
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-19T16:01:19+08:00">
                2017-03-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Objective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Objective-C</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上文已经简单介绍了kvo的原理及其用法，这篇介绍下它的底层实现，<a href="https://www.mikeash.com/pyblog/friday-qa-2009-01-23.html" target="_blank" rel="external">原文</a>，英语好的同学直接看这里。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们已经知道，继承自NSObject且命名符合规范的property是自动实现了kvo compliance的，我们无需在class内部添加任何代码，即可实现对属性的监听，那它到底是怎么实现的呢？其实就是runtime的功劳。当我们第一次对某个对象添加监听时，kvo会在运行时创建一个class继承自被监听对象的class，且这个新建的class会重写被监听key的setter。然后，被监听对象的isa指针被指向了这个新建的类(不熟悉runtime的同学推荐看南峰子大神的<a href="http://southpeak.github.io/categories/objectivec/" target="_blank" rel="external">runtime系列</a>),这就是传说中的isa swizzling。stackoverflow有一篇介绍method swizzling和isa swizzling挺好的，感兴趣的可以看<a href="http://stackoverflow.com/questions/38877465/are-method-swizzling-and-isa-swizzling-the-same-thing" target="_blank" rel="external">这里</a></p>
<p>所以重点就在重写的setter里面，因为被监听属性的值的改变一定会调用这个setter，重写setter就可以实现改变值得时候对observer发出改变通知(当然你或许会通过直接访问实例变量来改变属性值，但是如果你想实现kvo通知，这么做是不允许的，这个问题我上篇文章忘记提到：即如果通过下划线+属性名称直接访问实例变量来改变属性，是不会触发kvo通知的)</p>
<p>当然，苹果肯定不想暴露这种实现细节。所以除了setter，新建类还重写了-class方法去返回原来的类！</p>
<p>解释了一大通，肯定还是没代码来得快，看看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line"></div><div class="line">@interface TestClass : NSObject</div><div class="line">@property int x;</div><div class="line">@property int y;</div><div class="line">@property int z;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation TestClass</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">// 获取方法列表，返回方法名数组</div><div class="line">static NSArray *ClassMethodNames(Class c) &#123;</div><div class="line">    NSMutableArray *array = [NSMutableArray array];</div><div class="line">    unsigned int methodCount = 0;</div><div class="line">    Method *methodList = class_copyMethodList([TestClass class], &amp;methodCount);</div><div class="line">    for (unsigned int i = 0; i &lt; methodCount; i++) &#123;</div><div class="line">        [array addObject:NSStringFromSelector(method_getName(methodList[i]))];</div><div class="line">    &#125;</div><div class="line">    free(methodList);</div><div class="line">    return array;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void PrintDescription(NSString *name, id obj) &#123;</div><div class="line">    NSString *str = [NSString stringWithFormat:</div><div class="line">                     @&quot;%@: %@\n\tNSObject class %s\n\tlibobjc class %@\n\timplements methods &lt;%@&gt;&quot;,</div><div class="line">                     name,</div><div class="line">                     obj,</div><div class="line">                     class_getName([obj class]),</div><div class="line">                     object_getClass(obj),</div><div class="line">                     [ClassMethodNames(object_getClass(obj)) componentsJoinedByString:@&quot;, &quot;]];</div><div class="line">    printf(&quot;%s\n&quot;, [str UTF8String]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        TestClass *x = [[TestClass alloc] init];</div><div class="line">        TestClass *y = [[TestClass alloc] init];</div><div class="line">        TestClass *xy = [[TestClass alloc] init];</div><div class="line">        TestClass *control = [[TestClass alloc] init];</div><div class="line">        </div><div class="line">        [x addObserver:x forKeyPath:@&quot;x&quot; options:0 context:NULL];</div><div class="line">        [xy addObserver:xy forKeyPath:@&quot;x&quot; options:0 context:NULL];</div><div class="line">        [y addObserver:y forKeyPath:@&quot;y&quot; options:0 context:NULL];</div><div class="line">        [xy addObserver:xy forKeyPath:@&quot;y&quot; options:0 context:NULL];</div><div class="line">        </div><div class="line">        PrintDescription(@&quot;control&quot;, control);</div><div class="line">        PrintDescription(@&quot;x&quot;, x);</div><div class="line">        PrintDescription(@&quot;y&quot;, y);</div><div class="line">        PrintDescription(@&quot;xy&quot;, xy);</div><div class="line">        </div><div class="line">        printf(&quot;Using NSObject methods, normal setX: is %p, overridden setX: is %p\n&quot;,</div><div class="line">               [control methodForSelector:@selector(setX:)],</div><div class="line">               [x methodForSelector:@selector(setX:)]);</div><div class="line">        printf(&quot;Using libobjc functions, normal setX: is %p, overridden setX: is %p\n&quot;,</div><div class="line">               method_getImplementation(class_getInstanceMethod(object_getClass(control),</div><div class="line">                                                                @selector(setX:))),</div><div class="line">               method_getImplementation(class_getInstanceMethod(object_getClass(x),</div><div class="line">                                                                @selector(setX:))));</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>让我们来分析一下代码：<br>首先，我们新建了一个TestClass类，并生命了x，y，z三个属性。<br>然后我们定义了一些基本方法，ClassMethodNames通过class_copyMethodList获取当前类的所有方法列表，注意class_copyMethodList只会返回当前类中定义的方法，不会返回super中的方法。PrintDescription打印出我们想要的运行时信息，对象类型(通过-class方法获取的)，对象真实类型(通过object_getClass获取)以及方法列表。<br>然后在main函数中，我们生成了4个TestClass的实例变量，x，y和xy分别对自身的x属性，y属性，x及y属性添加了监听，control主要用来对照，z属性没有被监听，也是用于对照。</p>
<p>我看来运行看看打印结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">control: &lt;TestClass: 0x100700250&gt;</div><div class="line">NSObject class TestClass</div><div class="line">libobjc class TestClass and address 0x1000023e8</div><div class="line">implements methods &lt;z, setY:, setX:, setZ:, x, y&gt;</div><div class="line">x: &lt;TestClass: 0x100700080&gt;</div><div class="line">NSObject class TestClass</div><div class="line">libobjc class NSKVONotifying_TestClass and address 0x100703630</div><div class="line">implements methods &lt;setY:, setX:, class, dealloc, _isKVOA&gt;</div><div class="line">y: &lt;TestClass: 0x1007000a0&gt;</div><div class="line">NSObject class TestClass</div><div class="line">libobjc class NSKVONotifying_TestClass and address 0x100703630</div><div class="line">implements methods &lt;setY:, setX:, class, dealloc, _isKVOA&gt;</div><div class="line">xy: &lt;TestClass: 0x100700230&gt;</div><div class="line">NSObject class TestClass</div><div class="line">libobjc class NSKVONotifying_TestClass and address 0x100703630</div><div class="line">implements methods &lt;setY:, setX:, class, dealloc, _isKVOA&gt;</div><div class="line">Using NSObject methods, normal setX: is 0x100001620, overridden setX: is 0x7fff9833012d</div><div class="line">Using libobjc functions, normal setX: is 0x100001620, overridden setX: is 0x7fff9833012d</div></pre></td></tr></table></figure></p>
<p>首先看一下control，可以看见-class和object_getClass返回的都是TestClass，且3个属性对应的setter和getter也都被打印；<br>观察x、y以及xy，出现了一个神奇的东西：NSKVONotifying_TestClass，没错，这就是上文提到的继承自TestClass生成的那个类，可以看到苹果给的命名规则是NSKVONotifying_ClassName，但有一点需要注意，虽然我们对x、y和xy三个对象都添加了监听，但苹果只生成了一个额外类，显然苹果认为如果同一个类的不同属性被监听时，不需要分别为其生成NSKVONotifying_ClassName，所以方法列表也都只包含被重写了的x，y的setter，z属性由于没有被监听，所以其setter和getter没有被重写，故不再NSKVONotifying_TestClass的方法列表中。<br>除此之外，我们发现还有额外的三个方法：-class是上文我们已经提到的，为了隐藏自己的实现，苹果重写了这个方法；dealloc方法也被重写了，应该是需要在回收的时候做一些清理工作；isKVOA则看起来像一个私有方法用于判断被监听对象的真实类型其实是NSKVONotifying_ClassName这么个动态生成的类。<br>然后我们在观察一下被打印的setX:的方法地址，分别打印了control对象和x对象的setX:方法,结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Using NSObject methods, normal setX: is 0x100001620, overridden setX: is 0x7fff9833012d</div><div class="line">Using libobjc functions, normal setX: is 0x100001620, overridden setX: is 0x7fff9833012d</div></pre></td></tr></table></figure></p>
<p>可见地址是不同的，即setX:被重写了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这里，我们已经基本了解了kvo的底层实现。但是还是有很多东西等待我们去继续发掘：动态生成的类中重写的setter是怎么实现从而发出通知的呢？当我们通过+automaticallyNotifiesObserversForKey方法来返回某个key的时候，苹果是怎么屏蔽其发出通知的呢。。待续。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://dengbowc.github.io/2017/03/18/认真对待生活，对待工作/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="邓波">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bolgIcon.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="一个二次猿的小站">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="一个二次猿的小站" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/18/认真对待生活，对待工作/" itemprop="url">
                  认真对待生活，对待工作
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-18T00:03:15+08:00">
                2017-03-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/daily/" itemprop="url" rel="index">
                    <span itemprop="name">daily</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天晚上去肯德基蹭了个厕所，洗完手准备出去的时候，前台看我在甩手上的水时叫住了我：“先生给您一些纸擦擦手吧。”我也没客气：“谢谢”。出来一边擦手一边思考：来北京也已经两年，遇到过形形色色的人和事，最让我在意的是我们这些在北京漂泊的人，真的都有自己的梦想么，真的有认真的过好自己的每一天么？就像这位给我手纸的服务员，她的行为并非义务，无非是做了加分，不做本分，但就是感觉会不一样！在我现在所在的公司，我也会遇到类似这样的对工作尽职尽责、一丝不苟的人，没别的，欣赏+敬佩+学习。但我们中的还有一些是什么样的呢？工作时浑浑噩噩应付交差，下班回家后刷剧游戏，过年抢票回去还得抢票回来，拿着不高不低的工资，日复一日，年不会超过五年，意义在哪？其实我们不是不会想，是大多数人都拒绝去思考这个问题，最大化的麻痹自己。做人没有梦想，确实是和咸鱼无二的。</p>
<p>没错，北京的房价是高的让人望而却步，但这并不是我们背井离乡几年之后还一无所成乃至一无所获回家的理由。如果你不满意你的工作，不能认真对待你的工作，为什么不换了它？如果你的实力不足以让你找到一份你心满意足甘之为其奋斗的工作，为何不在下班后拼命提升自己，还把大把的时光都放在消遣上呢？这是我每天都在告诫的东西，所以我从未中断过自己的学习。要知道，一周7天，至少5天你是在公司度过，一天24小时，至少1/3是在公司，如果真的是去混日子，真的是太没必要了，大把的青春时光干什么不好呢？</p>
<p>当然，我并不是让自己成为一个打工者才这么说，而是想让自己就算做打工者，也要做一个快乐的打工者，让老板欣赏，同事喜欢的打工者；一个闲暇之余会看看小书，锻个小炼，弹弹小琴打工者；一个可以让我的家人安心的打工者；一个可以让我女朋友托付未来的打工者。。。这样，即使在若干年以后，我也被北京的房价驱逐出境，还能不留遗憾的走吧！挥一挥手不带走一点雾霾。</p>
<p>我现在的梦想是以后我有能力开了北京，而不是北京开了我^_^。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://dengbowc.github.io/2017/03/17/kvo详解/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="邓波">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bolgIcon.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="一个二次猿的小站">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="一个二次猿的小站" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/17/kvo详解/" itemprop="url">
                  kvo详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-17T17:46:48+08:00">
                2017-03-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Objective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Objective-C</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上篇说道，kvo是基于kvc来实现的，现在来研究一下kvo的实现方式。</p>
<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>苹果的官方文档在<a href="https://developer.apple.com/library/etc/redirect/xcode/content/1189/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i" target="_blank" rel="external">这里</a><br>kvo是这么一种机制：当一个对象的属性发生改变后，另一个对象会收到其改变的通知。<br>假设我们生成这么两个类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@interface Account : NSObject</div><div class="line"></div><div class="line">@property (nonatomic ,assign) double balance;</div><div class="line"></div><div class="line">@property (nonatomic ,assign) double  interestRate;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation Account</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface Person : NSObject</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation Person</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>如果一个Account对象代表一个Person对象的银行账户，则Person的实例就需要实时了解其对应Account对象发生的变化。<br>我们可以通过让Person定时去查看Account来获取其变化，但显然这是一种很low的做法，在某些情况下可实践性也不高。对此，苹果为我们提供了kvo，即Key-Value Observing，来让Person能够在Account发生改变的时候立即监听到这个变化。</p>
<p>使用kvo，必须保证被监听对象(在本例中就是Account)是遵循kvo机制的。正常来说，如果我们新建了一个继承自NSObject或其子类的对象，并且我们用正常的方式(@property double balance)定义其属性，则该对象及其属性都是可监听的。当然我们也可以手动实现对象的可监听性，稍后介绍其做法。</p>
<h2 id="kvo的实现"><a href="#kvo的实现" class="headerlink" title="kvo的实现"></a>kvo的实现</h2><p><a href="https://developer.apple.com/library/prerelease/content/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOCompliance.html#//apple_ref/doc/uid/20002178-BAJEAIEE" target="_blank" rel="external">原文档</a><br>相信大家或多或少都已经用过kvo，实现起来无非就是三步：<br>1、addObserver:forKeyPath:options:context:.注册通知，这个消息是发向被监听者，第一个参数是监听对象，第二个参数是监听的属性keyPath，第三个options是一个枚举：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">typedef NS_OPTIONS(NSUInteger, NSKeyValueObservingOptions) &#123;</div><div class="line"></div><div class="line">    NSKeyValueObservingOptionNew = 0x01,</div><div class="line"></div><div class="line">    NSKeyValueObservingOptionOld = 0x02,</div><div class="line"></div><div class="line">    NSKeyValueObservingOptionInitial NS_ENUM_AVAILABLE(10_5, 2_0) = 0x04,</div><div class="line"></div><div class="line">    NSKeyValueObservingOptionPrior NS_ENUM_AVAILABLE(10_5, 2_0) = 0x08</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>前三个顾名思义，第一个会在被监听属性发生变化后把变化前的值也给你，第二个会给你变化后的新值，第三个会在初始化的时候直接给你一个初始值并回调给你，第四个比较特殊，它会在接收到变化值回调之前调用一次.在这次回调里你可以在监听值变化前做你想要的操作。<br>context参数的类型是一个(void *)指针,它会跟着通知一起通过回调方法返回给监听者，通常我们可能会只用keyPath去判断监听回调是来自哪一个被监听属性，但是这种做法并不可靠：如果监听者的父类监听了同样一个keyPath的时候这时候就会难以区分，这时候context的作用就可以体现出来了：给他一个静态变量的唯一地址就可以做出一个很好的context，根据被监听属性的名字来命名是一个不错的选择：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static void *PersonFullNameContext = &amp;PersonFullNameContext;</div></pre></td></tr></table></figure></p>
<p>用这种方式我们只需要对比地址，免去了字符串比较的苦恼。<br>注意：addObserver:forKeyPath:options:context:没有对参数添加强引用，须根据需要自行保存这几个参数。</p>
<p>2、监听对象实现<br>监听者实现自己的observeValueForKeyPath:ofObject:change:context:来接受监听回调通知，该方法的四个参数上文已介绍过，此处不再赘述。<br>这里介绍一下回调的实现过程，先看一下这几个定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// 定义了用于做回调中change字典的key值</div><div class="line">typedef NSString * NSKeyValueChangeKey NS_STRING_ENUM;</div><div class="line">// 用来表示变化类型的枚举值，主要是NSKeyValueChange这个枚举的四个值。</div><div class="line">FOUNDATION_EXPORT NSKeyValueChangeKey const NSKeyValueChangeKindKey;</div><div class="line">// 设置监听时option选择的是new</div><div class="line">FOUNDATION_EXPORT NSKeyValueChangeKey const NSKeyValueChangeNewKey;</div><div class="line">// 设置监听时option选择的是old</div><div class="line">FOUNDATION_EXPORT NSKeyValueChangeKey const NSKeyValueChangeOldKey;</div><div class="line">// 针对集合类型变化的key</div><div class="line">FOUNDATION_EXPORT NSKeyValueChangeKey const NSKeyValueChangeIndexesKey;</div><div class="line">// 设置监听时option选择的是prior</div><div class="line">FOUNDATION_EXPORT NSKeyValueChangeKey const NSKeyValueChangeNotificationIsPriorKey</div><div class="line"></div><div class="line">typedef NS_ENUM(NSUInteger, NSKeyValueChange) &#123;</div><div class="line">    // 表示属性通过setValueForKey或是setter改变或是willChangeValueForKey: or didChangeValueForKey:这  两个方法被调用时发出的回调</div><div class="line">    NSKeyValueChangeSetting = 1,</div><div class="line">    // 下面这三个都是针对表示类似MSMutableArray这种集合类型集合发生变化时的变化类型</div><div class="line">    NSKeyValueChangeInsertion = 2,</div><div class="line">    NSKeyValueChangeRemoval = 3,</div><div class="line">    NSKeyValueChangeReplacement = 4,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>当回调通知发出时，change字典通过NSKeyValueChangeKindKey这个key对应的value来表示发生了哪种变化。如果被监听对象的只发生了改变，则设置为NSKeyValueChangeSetting。通过observer添加监听时定义的option，change添加对应的new和old Key以及对应的value。如果是非对象类型，则会先封装成NSValue再填入字典。<br>如果变化的是一个集合类型，则NSKeyValueChangeKindKey存入的值会根据集合是被插入、删除还是替换从<br>NSKeyValueChangeInsertion = 2,<br>NSKeyValueChangeRemoval = 3,<br>NSKeyValueChangeReplacement = 4,<br>这三个里面选择一个</p>
<p>最后，observeValueForKeyPath:ofObject:change:context:方法的实现必须要调一下父类的实现以完成父类的监听：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123;</div><div class="line">    [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3、移除监听<br>通过removeObserver:forKeyPath:context:我们可以移除对某个对象属性的监听，这里面又体现出了定义一个唯一识别的context的好处：移除时我们并不需要做多余的判断，直接对比context地址即可，前提是context采用了我们之前说过的命名规则。<br>observer必须在dealloc里面移除所有自己添加的监听，否则回调消息会发向一个已经被release的对象，造成崩溃。</p>
<h2 id="进一步分析："><a href="#进一步分析：" class="headerlink" title="进一步分析："></a>进一步分析：</h2><p>上文说道，想要监听一个对象，则这个对象必须是遵循kvo机制(KVO Compliance)的，主要体现在3方面：<br>1.对象所属类必须是遵循kvc的( key-value coding compliant)，kvc规则看<a href="https://developer.apple.com/library/prerelease/content/documentation/Cocoa/Conceptual/KeyValueCoding/Compliant.html#//apple_ref/doc/uid/20002172" target="_blank" rel="external">这里</a><br>2.属性发生改变时，能够发送对应的kvo通知(notifications)<br>3.对于有依赖关系的属性做好监听关联(原话是Dependent keys are registered appropriately (see <a href="https://developer.apple.com/library/prerelease/content/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVODependentKeys.html#//apple_ref/doc/uid/20002179-BAJEAIEE" target="_blank" rel="external">Registering Dependent Keys</a>).翻译水平是在捉急，见谅)</p>
<p>解释一下第三点<br>如果监听的是一个非集合类型：<br>为我们上文定义的Person添加三个属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@interface Person : NSObject</div><div class="line"></div><div class="line">@property(nonatomic ,copy)NSString *firstName;</div><div class="line"></div><div class="line">@property(nonatomic ,copy)NSString *lastName;</div><div class="line"></div><div class="line">@property(nonatomic , readonly, copy)NSString *fullName;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>按照正常的逻辑，fullName应该直接重写getter来返回：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (NSString *)fullName &#123;</div><div class="line">    return [NSString stringWithFormat:@&quot;%@ %@&quot;,self.firstName,self.lastName];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>相对的，如果我们对一个Person的fullName添加了监听，那么firstName或是lastName若发生了改变，我们是希望可以进入监听回调的,但是由于我们没有对fullName做setter，所以fullName是无法监听的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    Person *person = [Person new];</div><div class="line">    person.firstName = @&quot;deng&quot;;</div><div class="line">    person.lastName = @&quot;bo&quot;;</div><div class="line">    self.person = person;</div><div class="line">    NSLog(@&quot;%@&quot;,person.fullName);</div><div class="line">    [self.person addObserver:self forKeyPath:@&quot;fullName&quot; options:NSKeyValueObservingOptionNew context:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</div><div class="line">    self.person.lastName = [self.person.lastName stringByAppendingString:@&quot;wc&quot;];</div><div class="line">    NSLog(@&quot;%@&quot;,self.person.fullName);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123;</div><div class="line">    NSLog(@&quot;changed%@&quot;,change);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>点击，虽然打印出已经改变的fullName，但是observe的回调方法是不走的。<br>好在苹果针对这种情况为我们提供了keyPathsForValuesAffectingValueForKey:这么个方法，我们来实现一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">+ (NSSet&lt;NSString *&gt; *)keyPathsForValuesAffectingValueForKey:(NSString *)key &#123;</div><div class="line">    NSSet *keyPaths = [super keyPathsForValuesAffectingValueForKey:key];</div><div class="line">    </div><div class="line">    if ([key isEqualToString:@&quot;fullName&quot;]) &#123;</div><div class="line">        NSArray *array = @[@&quot;firstName&quot;,@&quot;lastName&quot;];</div><div class="line">        keyPaths = [keyPaths setByAddingObjectsFromArray:array];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return keyPaths;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从方法的实现我们可以看出，我们实际上是把fullName和firstName及lastName的变化做了关联，即只要它俩发生变化，则class也会发出fullName改变的通知，从而实现监听。运行程序，不出所料进了observe回调。<br><img src="/images/kvo详解1.png" alt="img"><br>我们还可以定义一个+ (NSSet *)keyPathsForValuesAffecting<key>这样名字的方法，也可以实现fullName的监听：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (NSSet *)keyPathsForValuesAffectingFullName &#123;</div><div class="line">    return [NSSet setWithObjects:@&quot;lastName&quot;, @&quot;firstName&quot;, nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure></key></p>
<p>它俩的效果是一样的。</p>
<p>但如果监听的是一个集合类型<br>比如我们新建了这么两个类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">@interface Employee : Person</div><div class="line"></div><div class="line">@property (nonatomic ,assign) CGFloat salary;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation Employee</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface Department : NSObject</div><div class="line"></div><div class="line">@property (nonatomic,strong)NSArray &lt;Employee *&gt; *employees;</div><div class="line"></div><div class="line">@property (nonatomic ,assign) CGFloat totalSalary;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation Department</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>我们会想让部门的totaoSalary和员工数组中的每一个employee对象的salary相关联，即如果员工数组中某个employee对象的salary发生了变化，totalSalary也会变化且可以被监听。按照上面的做法，你或许回想实现一个+keyPathsForValuesAffectingTotalSalary并返回一个employees.salary来解决问题，但对于集合类型，这是不允许的。我们可以用另一种方式解决：<br>通过Department类内部实现对employees数组中每一个元素添加一个监听来改变 totalSalary并发送通知，同时你需要注意当有新对象添加入employees或旧成员移出employees时控制监听的添加和移除，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context &#123;</div><div class="line">        </div><div class="line">        if (context == totalSalaryContext) &#123;</div><div class="line">            [self updateTotalSalary];</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">            // deal with other observations and/or invoke super...</div><div class="line">            &#125;</div><div class="line">    </div><div class="line">    - (void)updateTotalSalary &#123;</div><div class="line">        [self setTotalSalary:[self valueForKeyPath:@&quot;employees.@sum.salary&quot;]];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (void)setTotalSalary:(NSNumber *)newTotalSalary &#123;</div><div class="line">        </div><div class="line">        if (totalSalary != newTotalSalary) &#123;</div><div class="line">            [self willChangeValueForKey:@&quot;totalSalary&quot;];</div><div class="line">            _totalSalary = newTotalSalary;</div><div class="line">            [self didChangeValueForKey:@&quot;totalSalary&quot;];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (NSNumber *)totalSalary &#123;</div><div class="line">        return _totalSalary;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>上面介绍的3点要求除了第三条，只要对象是继承子NSObject，NSObject已经帮我们提供了默认的实现，即默认情况下property都是可监听的—-前提是属性的命名需要符合规范。类似以下这种吊用都会自动触发监听：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// Call the accessor method.</div><div class="line">    [account setName:@&quot;Savings&quot;];</div><div class="line">    </div><div class="line">    // Use setValue:forKey:.</div><div class="line">    [account setValue:@&quot;Savings&quot; forKey:@&quot;name&quot;];</div><div class="line">    </div><div class="line">    // Use a key path, where &apos;account&apos; is a kvc-compliant property of &apos;document&apos;.</div><div class="line">    [document setValue:@&quot;Savings&quot; forKeyPath:@&quot;account.name&quot;];</div><div class="line">    </div><div class="line">    // Use mutableArrayValueForKey: to retrieve a relationship proxy object.</div><div class="line">    Transaction *newTransaction = &lt;#Create a new transaction for the account#&gt;;</div><div class="line">    NSMutableArray *transactions = [account mutableArrayValueForKey:@&quot;transactions&quot;];</div><div class="line">    [transactions addObject:newTransaction];</div></pre></td></tr></table></figure></p>
<p>除此之外，有时我们也需要控制监听通知发送的过程，而且监听通知的手动实现和NSObject帮我们自动实现的监听也不是互斥的，如果你需要完全控制某一个property的监听通知的发送，重写NSObject的automaticallyNotifiesObserversForKey:方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)theKey &#123;</div><div class="line">    BOOL automatic = NO;</div><div class="line">    if ([theKey isEqualToString:@&quot;balance&quot;]) &#123;</div><div class="line">        automatic = NO;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        automatic = [super automaticallyNotifiesObserversForKey:theKey];</div><div class="line">    &#125;</div><div class="line">    return automatic;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如代码所示，balance属性被返回了NO，即balance变化的通知将不会被自动发出，如果需要手动实现通知的发出，需要实现在value变化的前后分别调用willChangeValueForKey:和didChangeValueForKey: 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)setBalance:(double)theBalance &#123;</div><div class="line">    [self willChangeValueForKey:@&quot;balance&quot;];</div><div class="line">    _balance = theBalance;</div><div class="line">    [self didChangeValueForKey:@&quot;balance&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们也可以控制无用通知的发出，比如虽然赋值，但是value并没有改变，此时没有必要发出通知：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)setBalance:(double)theBalance &#123;</div><div class="line">    if (theBalance != _balance) &#123;</div><div class="line">        [self willChangeValueForKey:@&quot;balance&quot;];</div><div class="line">        _balance = theBalance;</div><div class="line">        [self didChangeValueForKey:@&quot;balance&quot;];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果balance的改变会触发其他值的变化，则可以这么做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (void)setBalance:(double)theBalance &#123;</div><div class="line">    [self willChangeValueForKey:@&quot;balance&quot;];</div><div class="line">    [self willChangeValueForKey:@&quot;itemChanged&quot;];</div><div class="line">    _balance = theBalance;</div><div class="line">    _itemChanged = _itemChanged+1;</div><div class="line">    [self didChangeValueForKey:@&quot;itemChanged&quot;];</div><div class="line">    [self didChangeValueForKey:@&quot;balance&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>当然，这篇文章也只是介绍了kvo的用法以及一些基本原理，而kvo的底层实现则是依靠了isa-swizzling这么个黑魔法，挖坑待填。。。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://dengbowc.github.io/2017/03/15/kvc详解/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="邓波">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bolgIcon.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="一个二次猿的小站">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="一个二次猿的小站" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/15/kvc详解/" itemprop="url">
                  kvc详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-15T17:32:01+08:00">
                2017-03-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Objective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Objective-C</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>kvc，即Key-Value coding，是苹果为我们提供的不直接通过setter和getter来访问对象成员的一种方式，这篇文章主要介绍其原理和便利性。</p>
<h1 id="咳咳咳。。下面进入正题"><a href="#咳咳咳。。下面进入正题" class="headerlink" title="咳咳咳。。下面进入正题"></a>咳咳咳。。下面进入正题</h1><p>我们在日常开发中会经常使用到kvc中定义的方法，这些方法实际上是被包含在NSKeyValueCoding这么个协议里面的。继承自NSObejct的对象默认会遵守NSKeyValueCoding协议，且会继承NSObject对协议中方法的默认实现。想要同过kvc来访变量，需要：</p>
<h3 id="如果是访问对象属性"><a href="#如果是访问对象属性" class="headerlink" title="如果是访问对象属性"></a>如果是访问对象属性</h3><p>setValue:forKey: 和valueForKey:的默认实现是通过key去找accessMethod，如果没有找到且+（BOOL）accessInstanceVariablesDirectly返回了YES,则会去找对应的<em><key>，<key>，<iskey>，</iskey></key></key></em><iskey>的实例变量，这也是为何@private的成员变量可以通过kvc来赋值的原因。其实根据key来找成员变量并不是简单的直接下划线+变量名，apple为其制定了一个<a href="https://developer.apple.com/library/prerelease/content/documentation/Cocoa/Conceptual/KeyValueCoding/SearchImplementation.html#//apple_ref/doc/uid/20000955-CJBBBFFA" target="_blank" rel="external">搜索规则</a>。<br>(这里再提一嘴，如果你想实现真正的@private成员变量，在OC中只靠这一个关键字是不行的，因为kvc还是可以获取到，屏蔽kvc的获取可以通过重写+（BOOL）accessInstanceVariablesDirectly返回NO来实现，但是runtime还是可以获取到==。。)<br>如果没找到，调用valueForUndefinedKey:/setValue:forUndefinedKey:，默认的实现是抛出NSUndefinedKeyException这么一个异常。<br>假如我们定义了这么一个类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">@interface Person : NSObject</div><div class="line"></div><div class="line">@property(nonatomic ,copy)NSString *name;</div><div class="line"></div><div class="line">@property(nonatomic ,copy)NSString *mobile;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation Person</div><div class="line"></div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface Transaction : NSObject</div><div class="line"></div><div class="line">@property(nonatomic ,copy)NSString *date;</div><div class="line"></div><div class="line">@property(nonatomic ,assign)CGFloat amount;</div><div class="line"></div><div class="line">@property(nonatomic ,assign)NSInteger transId;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation Transaction </div><div class="line"></div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">@interface BankAccount : NSObject</div><div class="line">@property (nonatomic) NSNumber* currentBalance; // An attribute</div><div class="line">@property (nonatomic) Person* owner; // A to-one relation</div><div class="line">@property (nonatomic) NSArray&lt; Transaction* &gt;* transactions; // A to-many relation</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation BankAccount</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></iskey></p>
<p>根据上面的描述，默认我们可以用setValue:forKey: 和valueForKey:访问这几个属性，假设Person类中还包含了一个mobile的字符串属性，则可以通过valueForKeyPath:@”owner.mobile”来访问owner的mobile属性，使用valueForKeyPath的前提是keyPath中的成员都必须实现了NSKeyValueCoding协议的方法，否则会调用valueForUndefinedKey:/setValue:forUndefinedKey:，抛出异常。</p>
<p>当我们通过keyPath访问集合类型的时候，例如在本例中，访问了transactions.transId,则会自动帮我们返回包含transactions数组中所有的transId数据的数组:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">BankAccount *account = [BankAccount new];</div><div class="line">NSLog(@&quot;\ntransIds:%@&quot;,[account valueForKeyPath:@&quot;transactions.transId&quot;]);</div></pre></td></tr></table></figure></p>
<p>打印结果：<br><img src="/images/kvc详解1.png" alt="img"></p>
<p>类似getter，NSObject对于setter在NSKeyValueCoding中也有一套默认的实现规则，和getter基本类似，这里不再细说，但需要注意的是如果你尝试对一个基本类型的属性设置一个nil，则消息接收者会给自己发送一条setNilValueForKey:消息，其默认实现会抛出NSInvalidArgumentException异常。</p>
<h3 id="如果是访问容器属性-NSArray、NSSet等"><a href="#如果是访问容器属性-NSArray、NSSet等" class="headerlink" title="如果是访问容器属性(NSArray、NSSet等)"></a>如果是访问容器属性(NSArray、NSSet等)</h3><p>虽然我们还是可以通过valueForKey:来直接访问，但是苹果为我们提供了一种更为方便的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (NSMutableArray *)mutableArrayValueForKey:(NSString *)key</div></pre></td></tr></table></figure></p>
<p>使用这种方式的好处是可以直接通过获取到的mutableArray对象对array属性进行操作(不管是可变还是不可变),看代码：<br>先定义集合属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic,strong) NSArray *testArray;</div></pre></td></tr></table></figure></p>
<p>然后尝试修改testArray的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">    NSMutableArray *test = [self.account mutableArrayValueForKey:@&quot;testArray&quot;];</div><div class="line">    [test removeObjectAtIndex:1];</div><div class="line">    NSLog(@&quot;%@&quot;,[self.account valueForKey:@&quot;testArray&quot;]);</div></pre></td></tr></table></figure></p>
<p>运行后修改成功。这就是kvc自动帮我们实现的功能，想象一下如果不用这种方式你想修改一个不可变数组的属性需要的做法：先根据属性值创建一个可变数组，然后做删改后再赋值回去，其实kvc的内部实现也大致如此。此处有一个小细节：在修改前和修改后分别设置断点：<br><img src="/images/kvc详解2.png" alt="img"><br>运行查看控制台：<br>修改前：<br><img src="/images/kvc详解3.png" alt="img"><br>修改后：<br><img src="/images/kvc详解4.png" alt="img"><br>可见testArray的真实类型其实发生了改变，修改后它已经是一个可变数组。可以通过改变property关键字为copy来解决：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic,copy) NSArray *testArray;</div></pre></td></tr></table></figure></p>
<p>再次断点查看，发现修改前后已经都是不可变类型。所以NSObject的默认实现应该只是简单的将mutableArray赋值回属性，我们手动加个copy即可以解决。<br>其实- (NSMutableArray <em>)mutableArrayValueForKey:(NSString </em>)key的实现有一套完整的规则，这里只介绍其用法，感兴趣的同学可以看<a href="https://developer.apple.com/reference/objectivec/nsobject/1416339-mutablearrayvalueforkey" target="_blank" rel="external">这里</a>。</p>
<p>这个方法还有一个好处是容器属性的修改可以被kvo监听，默认我们是监听不到的：<br>为了方便测试，我们将testArray改为mutable类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic,strong) NSMutableArray  *testArray;</div></pre></td></tr></table></figure></p>
<p>添加监听：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">self.account = [BankAccount new];</div><div class="line">[self.account addObserver:self forKeyPath:@&quot;testArray&quot; options:NSKeyValueObservingOptionNew context:nil];</div></pre></td></tr></table></figure></p>
<p>先用原始方法修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self.account.testArray removeObjectAtIndex:1];</div></pre></td></tr></table></figure></p>
<p>监听回调是不会走的，采用kvc：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *test = [self.account mutableArrayValueForKey:@&quot;testArray&quot;];</div><div class="line">[test removeObjectAtIndex:1];</div></pre></td></tr></table></figure></p>
<p>回调执行。</p>
<p>以上介绍的如此好用的kvc的种种实现已经被NSObject默认完成，所以我们在日常开发中几乎没什么机会去重写NSKeyValueCoding协议中的方法，除非你需要修改一下kvc access属性的规则或自定义其他的一些功能。值得一提的是，kvo的实现就是依赖于kvc的，这里先挖个坑吧，以后补上。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://dengbowc.github.io/2017/03/14/timer和self的循环引用及其解决方式/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="邓波">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bolgIcon.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="一个二次猿的小站">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="一个二次猿的小站" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/14/timer和self的循环引用及其解决方式/" itemprop="url">
                  timer和self的循环引用及其解决方式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-14T11:29:05+08:00">
                2017-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Objective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Objective-C</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>日常开发过程中，我们经常会用到NSTimer这么个东西，但是相信不光我一个人被timer坑过：为啥停不掉？为啥控制器退出了这玩意还在跑。。。</p>
<p>一般我们使用timer都是这么个形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic,strong)NSTimer *timer;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    NSTimer *timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(timerTest) userInfo:nil repeats:YES];</div><div class="line">    self.timer = timer;</div><div class="line">    [[NSRunLoop mainRunLoop]addTimer:self.timer forMode:NSDefaultRunLoopMode];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)timerTest &#123;</div><div class="line">    NSLog(@&quot;test log&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)dealloc &#123;</div><div class="line">    NSLog(@&quot;i go&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>当本控制pop出去的时候，你会发现timer还在跑，回调会一直执行，切dealloc方法并没有走，没错，传说中的内存泄漏出现了。</p>
<h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>查看一下timer的文档：<a href="https://developer.apple.com/reference/foundation/nstimer?language=objc" target="_blank" rel="external">NSTimer</a><br>即timer会对其target加一个强引用，如果self也持有timer，就会造成retain cycle。</p>
<p><img src="/images/Snip20170314_13.png" alt="img"></p>
<p>对解决这种循环引用已经很有经验的你或许会选择这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic,weak)NSTimer *timer;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>可惜运行结果并不是你想的那样，这时因为这里面不光是self-timer的循环引用，还多了个runloop，timer加入到runloop时，runloop会对其也添加一个循环引用：</p>
<p><img src="/images/Snip20170314_14.png" alt="img"></p>
<p>可见，即使self没有强引用timer，由于runloop一直抓着timer(只要timer还没有invalidate)，所以self也会由于timer对target的强引用而无法释放。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="在合适的时机invalidate掉timer"><a href="#在合适的时机invalidate掉timer" class="headerlink" title="在合适的时机invalidate掉timer"></a>在合适的时机invalidate掉timer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidDisappear:(BOOL)animated &#123;</div><div class="line">    [super viewDidDisappear:animated];</div><div class="line">    [self.timer invalidate];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>类似这种处理，可以让runloop释放对timer的强引用，同时invalidate方法不光将timer移除出runloop，还会释放其对target的强引用，从而解决了循环引用的问题。</p>
<h3 id="通过消息转发来解决"><a href="#通过消息转发来解决" class="headerlink" title="通过消息转发来解决"></a>通过消息转发来解决</h3><p>新建一个proxy类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">@interface TimerProxy : NSProxy</div><div class="line"></div><div class="line">- (instancetype)initWithTarget:(id)target;</div><div class="line"></div><div class="line">@property (nonatomic,weak)id target;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation TimerProxy</div><div class="line"></div><div class="line">- (instancetype)initWithTarget:(id)target &#123;</div><div class="line">    _target = target;</div><div class="line">    </div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)forwardingTargetForSelector:(SEL)selector &#123;</div><div class="line">    return _target;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)forwardInvocation:(NSInvocation *)invocation &#123;</div><div class="line">    void *null = NULL;</div><div class="line">    [invocation setReturnValue:&amp;null];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector &#123;</div><div class="line">    return [NSObject instanceMethodSignatureForSelector:@selector(init)];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>然后在把其作为timer的target：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    TimerProxy *proxy = [[TimerProxy alloc]initWithTarget:self];</div><div class="line">    </div><div class="line">    NSTimer *timer = [NSTimer timerWithTimeInterval:1 target:proxy selector:@selector(timerTest) userInfo:nil repeats:YES];</div><div class="line">    self.timer = timer;</div><div class="line">    [[NSRunLoop mainRunLoop]addTimer:self.timer forMode:NSDefaultRunLoopMode];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>程序运行，发现控制器dealloc成功打印，但到这里还是有问题的，因为timer和它的target还没有被释放。<br>所以要在dealloc里面把timer给invalidate掉：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)dealloc &#123;</div><div class="line">    NSLog(@&quot;i go&quot;);</div><div class="line">    [self.timer invalidate];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后的关系图为：</p>
<p><img src="/images/Snip20170314_15.png" alt="img"></p>
<p>可见控制器是可以被释放的，但是timer需要在控制器dealloc的时候进行处理。</p>
<p>不了解消息转发的同学请参考<a href="http://southpeak.github.io/2014/11/03/objective-c-runtime-3/" target="_blank" rel="external">这篇文章</a>。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://dengbowc.github.io/2017/02/22/hexo搭建-吐槽/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="邓波">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bolgIcon.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="一个二次猿的小站">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="一个二次猿的小站" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/22/hexo搭建-吐槽/" itemprop="url">
                  hexo搭建+吐槽
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-22T11:16:51+08:00">
                2017-02-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/daily/" itemprop="url" rel="index">
                    <span itemprop="name">daily</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>   啦啦啦，也算是有了一个自己的个人小站了~花了近一天的时间，用的貌似是最大众的hexo+next哈==<br>搬运一下吧：<br><a href="http://ibruce.info/2013/11/22/hexo-your-blog/?utm_source=tuicool" target="_blank" rel="external">博客搭建</a><br><a href="http://ibruce.info/2013/11/26/markdown/" target="_blank" rel="external">markdown语法</a><br><a href="https://segmentfault.com/a/1190000002632530" target="_blank" rel="external">hexo常用命令</a></p>
<p>   主要是希望用这个来记录一下自己生活上的感悟，但是鉴于本人是个懒人，可能更新会很慢吧==</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  

          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/bolgIcon.jpg"
               alt="邓波" />
          <p class="site-author-name" itemprop="name">邓波</p>
           
              <p class="site-description motion-element" itemprop="description">邓波的个人站</p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">邓波</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
